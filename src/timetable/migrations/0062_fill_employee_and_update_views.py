# Generated by Django 2.2.16 on 2021-04-21 14:31

from django.db import migrations
from django.db.models import Subquery, OuterRef


def fill_employee(apps, schema_editor):
    WorkerDay = apps.get_model('timetable', 'WorkerDay')
    Employment = apps.get_model('base', 'Employment')
    Employee = apps.get_model('base', 'Employee')

    WorkerDay.objects.filter(
        employment__isnull=True,
        worker__isnull=False,
    ).update(
        employment=Subquery(
            Employment.objects.filter(
                user_id=OuterRef('worker_id'),
                dt_hired__gte=OuterRef('dt'),
                dt_fired__lte=OuterRef('dt'),
            ).values('id')[:1],
        )
    )

    WorkerDay.objects.filter(
        worker__isnull=False,
        employment__isnull=False,
        employee__isnull=True,
    ).update(
        employee=Subquery(
            Employee.objects.filter(
                user_id=OuterRef('worker_id'),
            ).values('id')[:1],
        )
    )


def update_views(apps, schema_editor):
    schema_editor.execute(
        """
        create or replace view timetable_plan_and_fact_hours as
        select string_agg(wd.id::text, '-'::text order by wd.is_fact) as id,
                wd.dt AS dt,
                wd.shop_id AS shop_id,
                s.name AS shop_name,
                s.code AS shop_code,
                employee.user_id AS worker_id,
                wd.type as wd_type,
                concat(u.last_name, ' ', u.first_name, ' ', u.middle_name) AS worker_fio,
                coalesce((sum(date_part('epoch'::text, GREATEST(wd.work_hours, '00:00:00'::interval)) / 3600::double precision) FILTER (WHERE wd.is_fact is True))::double precision, 0::double precision) AS fact_work_hours,
                coalesce((sum(date_part('epoch'::text, GREATEST(wd.work_hours, '00:00:00'::interval)) / 3600::double precision) FILTER (WHERE wd.is_fact is False))::double precision, 0::double precision) AS plan_work_hours,
                ((min(dttm_work_start) filter (where wd.is_fact is True) - min(dttm_work_start) filter (where wd.is_fact is False)) > network.allowed_interval_for_late_arrival)::int AS late_arrival,
                ((max(dttm_work_end) filter (where wd.is_fact is False) - max(dttm_work_end) filter (where wd.is_fact is True)) > network.allowed_interval_for_early_departure)::int AS early_departure,
                CASE WHEN (count(*) FILTER (WHERE wd.is_fact is False and wd.is_vacancy is True)) = 1 THEN True ELSE False END as is_vacancy,
                (count(*) FILTER (WHERE wd.is_fact is True and wd.dttm_work_start is not null) + count(*) FILTER (WHERE wd.is_fact is True and wd.dttm_work_end is not null))::int as ticks_fact_count,
                (coalesce(count(*) FILTER (WHERE wd.is_fact is False and wd.type='W'), 0) * 2)::int as ticks_plan_count,
                u.username as worker_username,
                coalesce(wd_details_wt_name.name, '') as work_type_name,
                DATE_TRUNC('minute', min(dttm_work_start) filter (where wd.is_fact is False)) AS dttm_work_start_plan,
                DATE_TRUNC('minute', max(dttm_work_end) filter (where wd.is_fact is False)) AS dttm_work_end_plan,
                DATE_TRUNC('minute', min(dttm_work_start) filter (where wd.is_fact is True)) AS dttm_work_start_fact,
                DATE_TRUNC('minute', max(dttm_work_end) filter (where wd.is_fact is True)) AS dttm_work_end_fact,
                (count(*) FILTER (WHERE wd.is_fact is True and wd.dttm_work_start is not null))::int as ticks_comming_fact_count,
                (count(*) FILTER (WHERE wd.is_fact is True and wd.dttm_work_end is not null))::int as ticks_leaving_fact_count,
                count(*) FILTER (WHERE wd.is_fact is False and wd.created_by_id is NULL) as auto_created_plan,
                count(*) FILTER (WHERE wd.is_fact is True and wd.created_by_id is NULL) as auto_created_fact,
                employee.tabel_code,
                wd.employee_id
        from timetable_workerday wd
            inner join base_shop s on wd.shop_id = s.id
            inner join base_employee employee on wd.employee_id = employee.id
            inner join base_user u on employee.user_id = u.id
            inner join base_network network on s.network_id = network.id
            left join timetable_workerdaycashboxdetails wd_details on wd.id = wd_details.worker_day_id and wd_details.id = (
                SELECT max(wd_details2.id)
                FROM timetable_workerdaycashboxdetails wd_details2
                WHERE wd.id = wd_details2.worker_day_id
            )
            left join timetable_worktype wd_details_wt on wd_details.work_type_id = wd_details_wt.id
            left join timetable_worktypename wd_details_wt_name on wd_details_wt.work_type_name_id = wd_details_wt_name.id
        where wd.is_approved is True
            and NOT (wd.employment_id IS NULL AND wd.type = 'W' AND wd.employee_id IS NOT NULL)
            and wd.employee_id in (
                select be.employee_id from base_employment be
                where be.employee_id = wd.employee_id and 
                    (be.dt_hired <= wd.dt or be.dt_hired is null) and
                    (be.dt_fired >= wd.dt or be.dt_fired is null)
                )
        group by wd.dt,
            employee.user_id,
            employee.tabel_code,
            wd.type,
            u.username,
            concat(u.last_name, ' ', u.first_name, ' ', u.middle_name),
            wd.shop_id,
            s.name,
            s.code,
            coalesce(wd_details_wt_name.name, ''),
            network.id,
            wd.employee_id
        ;
        """
    )
    schema_editor.execute("""\
        create or replace view plan_and_fact_hours as
        select tt_pf.dt AS "Дата",
               tt_pf.shop_id AS "ID Магазина",
               tt_pf.shop_name AS "Магазин",
               tt_pf.shop_code AS "Код магазина",
               tt_pf.employee_id::bigint AS "ID Сотрудника",
               tt_pf.worker_fio AS "Сотрудник",
               round(tt_pf.fact_work_hours::numeric, 2)::double precision AS "Фактические часы работы",
               round(tt_pf.plan_work_hours::numeric, 2)::double precision AS "Плановые часы работы",
               tt_pf.late_arrival AS "Опоздания",
               tt_pf.early_departure AS "Ранний уход",
               tt_pf.is_vacancy::int as "Вакансия",
               tt_pf.is_vacancy as "is_vacancy",
               tt_pf.ticks_fact_count as "К-во отметок факт",
               tt_pf.ticks_plan_count as "К-во отметок план",
               tt_pf.worker_username as "Табельный номер",
               tt_pf.work_type_name as "Тип работ",
               tt_pf.auto_created_plan as "Авт-ки созданный план",
               tt_pf.auto_created_fact as "Авт-ки созданный факт",
               tt_pf.tabel_code AS "Табельный номер трудоустройства",
               tt_pf.worker_id AS "ID Пользователя"
        from timetable_plan_and_fact_hours tt_pf
        where tt_pf.wd_type = 'W'""")

    schema_editor.execute("""\
         create or replace view prod_cal_work_hours as
         SELECT date_trunc('month'::text, pd.dt::timestamp with time zone)::date AS dt,
            employee.user_id,
            u.username,
            e.shop_id,
            s.code AS shop_code,
            sum(
                CASE
                    WHEN pd.type::text = 'W'::text THEN 8
                    WHEN pd.type::text = 'S'::text THEN 7
                    WHEN pd.type::text = 'H'::text THEN 0
                    ELSE 0
                END::double precision * COALESCE(wp.hours_in_a_week::integer, 40)::double precision / 40::double precision * e.norm_work_hours::double precision / 100::double precision) AS norm_hours,
           wtn.name as work_type_name
           FROM base_productionday pd
             JOIN base_employment e ON pd.dt >= e.dt_hired AND pd.dt <= e.dt_fired
             JOIN base_employee employee ON e.employee_id = employee.id
             JOIN base_user u ON employee.user_id = u.id
             JOIN base_shop s ON e.shop_id = s.id
             LEFT JOIN timetable_employmentworktype ewt on e.id = ewt.employment_id AND ewt.id = (
                SELECT min(ewt2.id)
                FROM timetable_employmentworktype ewt2
                inner join timetable_worktype wt2 on ewt2.work_type_id = wt2.id
                WHERE e.id = ewt2.employment_id
             )
             LEFT JOIN timetable_worktype wt on ewt.work_type_id = wt.id and wt.shop_id = e.shop_id and wt.dttm_deleted is null
             LEFT JOIN timetable_worktypename wtn on wt.work_type_name_id = wtn.id
             LEFT JOIN base_workerposition wp ON e.position_id = wp.id
          GROUP BY (date_trunc('month'::text, pd.dt::timestamp with time zone)::date), employee.user_id, u.username, e.shop_id, s.code, wtn.name;""")

    schema_editor.execute("""\
        create or replace view v_mda_users as
        SELECT DISTINCT u.id,
        u.username,
        u.last_name,
        u.first_name,
        u.middle_name,
        u.email,
        e.dt_hired,
        e.dt_fired,
        e.dttm_deleted IS NULL AND e.dt_hired <= CURRENT_TIMESTAMP::date AND (e.dt_fired IS NULL OR e.dt_fired >= CURRENT_TIMESTAMP::date) AS active,
            CASE
                WHEN s.level = 0 THEN 'COMPANY'::text
                WHEN s.level = 1 THEN 'DIVISION'::text
                WHEN s.level = 2 THEN 'REGION'::text
                WHEN s.level = 3 THEN 'SHOP'::text
                ELSE NULL::text
            END AS level,
            CASE
                WHEN (EXISTS ( SELECT s2.id
                   FROM base_shop s2
                  WHERE s2.id = s.id AND s2.director_id = u.id)) AND (g.code::text = 'director'::text OR fg.code::text = 'director'::text) THEN 'DIR'::text
                WHEN g.code::text = 'worker'::text AND fg.code IS NULL THEN 'MANAGER'::text
                ELSE NULL::text
            END AS role,
        s.name AS shop_name,
        s.code AS shop_code,
        wp.name AS position_name,
        wp.code AS position_code,
        g.name AS position_group_name,
        g.code AS position_group_code,
        fg.name AS func_group_name,
        fg.code AS func_group_code,
        u.dttm_modified AS user_last_modified,
        e.dttm_modified AS employment_last_modified,
        wp.dttm_modified AS position_last_modified,
        GREATEST(u.dttm_modified, e.dttm_modified, wp.dttm_modified) AS last_modified
       FROM base_employment e
         JOIN base_employee employee ON e.employee_id = employee.id
         JOIN base_user u ON employee.user_id = u.id
         JOIN base_shop s ON e.shop_id = s.id
         LEFT JOIN base_workerposition wp ON e.position_id = wp.id
         LEFT JOIN base_group fg ON e.function_group_id = fg.id
         LEFT JOIN base_group g ON wp.group_id = g.id
         LEFT JOIN timetable_workerday wdpa ON employee.id = wdpa.employee_id AND wdpa.dt = now()::date AND wdpa.is_fact = false AND wdpa.is_approved = true
         LEFT JOIN timetable_workerday wdpna ON employee.id = wdpna.employee_id AND wdpna.dt = now()::date AND wdpna.is_fact = false AND wdpna.is_approved = false
      WHERE (e.dttm_deleted IS NULL OR e.dttm_deleted >= (CURRENT_TIMESTAMP - '60 days'::interval)) AND (s.dttm_deleted IS NULL OR s.dttm_deleted >= (CURRENT_TIMESTAMP - '60 days'::interval)) AND (s.dt_closed IS NULL OR s.dt_closed >= (CURRENT_TIMESTAMP - '60 days'::interval)) AND e.dt_hired < e.dt_fired AND (fg.code IS NULL OR (fg.code::text <> ALL (ARRAY['admin'::text, 'controller'::text]))) AND (employee.user_id <> ALL (ARRAY[1::bigint, 2::bigint])) AND e.dt_fired > '2020-10-01'::date AND e.dt_hired <= CURRENT_TIMESTAMP::date AND (NOT wp.group_id = 3 OR wp.group_id IS NULL OR wp.group_id = 3 AND (wdpa.type IS NULL OR (wdpa.type::text <> ALL (ARRAY['M'::text, 'S'::text]))) AND (wdpna.type IS NULL OR (wdpna.type::text <> ALL (ARRAY['M'::text, 'S'::text]))));
             ;""")


class Migration(migrations.Migration):
    dependencies = [
        ('base', '0092_auto_20210421_1431'),
        ('timetable', '0061_auto_20210421_1314'),
    ]

    operations = [
        migrations.RunPython(fill_employee, migrations.RunPython.noop),
        migrations.RunPython(update_views, migrations.RunPython.noop),
    ]
